<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Floor Plan Live Tracking (Edge-Mapped Heading)</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    h1 {
      margin: 0.5em 0 0.2em;
    }
    #info {
      margin-bottom: 0.5em;
      font-size: 0.9em;
    }
    #floorCanvas {
      background: #fff;
      cursor: crosshair;
    }
    #stats {
      margin: 0.5em 0;
      font-size: 1em;
    }
    .bold {
      font-weight: bold;
    }
    button {
      margin: 0.5em;
      padding: 0.5em 1em;
      font-size: 1em;
      cursor: pointer;
    }
    #status {
      font-weight: bold;
      color: blue;
      margin-top: 0.5em;
    }
  </style>
</head>
<body>
  <h1>Floor Plan Live Tracking</h1>
  <div id="info">
    1) Click on the floor plan to set your <strong>starting position</strong>.<br/>
    2) Move around with your device to see live tracking and heading.<br/>
    3) If heading is reversed, use "Calibrate Heading" or adjust code (see notes).
  </div>

  <!-- Canvas for floor plan and live drawing -->
  <canvas id="floorCanvas" width="800" height="600"></canvas>
  
  <!-- Stats & Controls -->
  <div id="stats">
    <p><strong>Steps:</strong> <span id="stepsCount">0</span></p>
    <p><strong>Heading:</strong> <span id="headingDeg">0</span>°</p>
    <p><strong>Position (Canvas px):</strong> 
      X=<span id="posX">0</span>, 
      Y=<span id="posY">0</span>
    </p>
    <p><strong>Acceleration (Filtered):</strong> 
      <span id="accX">0</span>, 
      <span id="accY">0</span>, 
      <span id="accZ">0</span>
    </p>
    <button id="resetBtn">Reset</button>
    <button id="calibrateBtn">Calibrate Heading</button>
    <div id="status">Initializing...</div>
  </div>

  <!-- Kalman filter library for smoothing orientation -->
  <script src="https://cdn.jsdelivr.net/npm/kalmanjs"></script>

  <script>
    /********************************************************
     * 1) LOAD THE FLOOR PLAN IMAGE INTO THE CANVAS
     ********************************************************/
    const canvas = document.getElementById("floorCanvas");
    const ctx = canvas.getContext("2d");

    // Replace "image.png" with the path to your floor plan image:
    const floorPlanSrc = "image.png"; 
    const floorPlan = new Image();
    floorPlan.src = floorPlanSrc;

    function drawFloorPlan() {
      ctx.drawImage(floorPlan, 0, 0, canvas.width, canvas.height);
    }

    /********************************************************
     * 2) USER POSITION, STEP DETECTION, AND TRAJECTORY
     ********************************************************/
    let userX = null;         // in canvas pixels
    let userY = null;         // in canvas pixels
    let heading = 0;          // device orientation in degrees
    let baseHeading = 0;      // heading offset for calibration
    let useCalibratedHeading = false;

    // Trajectory
    let trajectoryPoints = []; // array of {x, y} in canvas coords

    // Step detection (peak–valley)
    let stepCount = 0;
    const stepLengthMeters = 0.7;     // average step length in meters
    const pixelsPerMeter = 10;        // scale factor for your floor plan
    let stepThresholdHigh = 2.0;      // "peak" threshold
    let stepThresholdLow = 1.0;       // "valley" threshold
    let peakDetected = false;
    let lastPeakTime = 0;
    let minStepInterval = 500;        // ms between steps

    // Gravity for high-pass filtering
    let gravityX = 0, gravityY = 0, gravityZ = 0;
    const alpha = 0.9;

    // Stationary detection
    const motionBufferSize = 20;
    let motionBuffer = [];
    let isStationary = true;
    const stationaryStdDevThreshold = 0.3; // tweak as needed

    // Simple function to compute standard deviation
    function computeStdDev(arr) {
      if (!arr.length) return 0;
      const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
      const variance = arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
      return Math.sqrt(variance);
    }

    // Kalman filter for heading
    const headingKF = new KalmanFilter({ R: 0.01, Q: 3 });

    /********************************************************
     * 3) DRAWING FUNCTIONS
     ********************************************************/
    function drawEverything() {
      // 1) Draw floor plan
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFloorPlan();

      // 2) Draw trajectory line
      if (trajectoryPoints.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        for (let i = 0; i < trajectoryPoints.length; i++) {
          const pt = trajectoryPoints[i];
          if (i === 0) {
            ctx.moveTo(pt.x, pt.y);
          } else {
            ctx.lineTo(pt.x, pt.y);
          }
        }
        ctx.stroke();
      }

      // 3) Draw current position and heading arrow
      if (userX !== null && userY !== null) {
        // Draw red dot for position
        ctx.beginPath();
        ctx.arc(userX, userY, 5, 0, 2 * Math.PI);
        ctx.fillStyle = "red";
        ctx.fill();

        // Calculate effective heading from sensor data:
        let effectiveHeading = useCalibratedHeading ? (heading - baseHeading) : heading;
        effectiveHeading = (effectiveHeading + 360) % 360;
        // Map observed ranges to fixed directions:
        // if (effectiveHeading >= 90 && effectiveHeading <= 130) {
        //   effectiveHeading = 270;      // Upper edge → y positive (downward)
        // } else if (effectiveHeading >= 0 && effectiveHeading <= 50) {
        //   effectiveHeading = 0;       // Right edge → x positive
        // } else if (effectiveHeading >= 260 && effectiveHeading <= 310) {
        //   effectiveHeading = 90;     // Bottom edge → y negative (upward)
        // } else if (effectiveHeading >= 170 && effectiveHeading <= 230) {
        //   effectiveHeading = 180;     // Left edge → x negative
        // }
        const rad = effectiveHeading * Math.PI / 180;
        const arrowLen = 15; // arrow length in pixels

        const arrowX = userX + arrowLen * Math.cos(rad);
        const arrowY = userY + arrowLen * Math.sin(rad);

        // Draw arrow line
        ctx.beginPath();
        ctx.moveTo(userX, userY);
        ctx.lineTo(arrowX, arrowY);
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw arrowhead
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(
          arrowX - 5 * Math.cos(rad - Math.PI / 6),
          arrowY - 5 * Math.sin(rad - Math.PI / 6)
        );
        ctx.lineTo(
          arrowX - 5 * Math.cos(rad + Math.PI / 6),
          arrowY - 5 * Math.sin(rad + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = "blue";
        ctx.fill();
      }
    }

    // Add a new point to the trajectory if it's sufficiently far from the last one
    function addTrajectoryPoint(x, y) {
      if (!trajectoryPoints.length) {
        trajectoryPoints.push({ x, y });
        return;
      }
      const last = trajectoryPoints[trajectoryPoints.length - 1];
      const dx = x - last.x;
      const dy = y - last.y;
      if (Math.sqrt(dx * dx + dy * dy) > 2) {
        trajectoryPoints.push({ x, y });
      }
    }

    /********************************************************
     * 4) EVENT LISTENERS
     ********************************************************/
    // A) Load image and draw once
    floorPlan.onload = function() {
      drawEverything();
    };

    // B) Click canvas to set starting position
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      userX = e.clientX - rect.left;
      userY = e.clientY - rect.top;

      stepCount = 0;
      trajectoryPoints = [];
      addTrajectoryPoint(userX, userY);

      drawEverything();
    });

    // C) Device orientation: update heading
    window.addEventListener("deviceorientation", (event) => {
      const rawHeading = event.alpha || 0;
      heading = headingKF.filter(rawHeading);
      document.getElementById("headingDeg").innerText = heading.toFixed(2);
    });

    // D) Device motion: step detection and stationary detection
    window.addEventListener("devicemotion", (event) => {
      // If starting position isn't set, do nothing
      if (userX === null || userY === null) return;

      // 1) Remove gravity (high-pass filtering)
      const rawX = event.accelerationIncludingGravity.x || 0;
      const rawY = event.accelerationIncludingGravity.y || 0;
      const rawZ = event.accelerationIncludingGravity.z || 0;

      gravityX = alpha * gravityX + (1 - alpha) * rawX;
      gravityY = alpha * gravityY + (1 - alpha) * rawY;
      gravityZ = alpha * gravityZ + (1 - alpha) * rawZ;

      const linX = rawX - gravityX;
      const linY = rawY - gravityY;
      const linZ = rawZ - gravityZ;

      // 2) Compute magnitude and update rolling buffer
      const magnitude = Math.sqrt(linX * linX + linY * linY + linZ * linZ);
      motionBuffer.push(magnitude);
      if (motionBuffer.length > motionBufferSize) {
        motionBuffer.shift();
      }
      const stdDev = computeStdDev(motionBuffer);
      isStationary = (stdDev < stationaryStdDevThreshold);

      // 3) Step detection (only if not stationary)
      const now = performance.now();
      if (!isStationary) {
        if (!peakDetected && magnitude > stepThresholdHigh) {
          peakDetected = true;
        } else if (peakDetected && magnitude < stepThresholdLow) {
          if (now - lastPeakTime > minStepInterval) {
            stepCount++;
            document.getElementById("stepsCount").innerText = stepCount;

            // Calculate effective heading for movement using the same mapping logic
            let effectiveHeading = useCalibratedHeading ? (heading - baseHeading) : heading;
            effectiveHeading = (effectiveHeading + 360) % 360;
            if (effectiveHeading >= 90 && effectiveHeading <= 130) {
              effectiveHeading = 270;
            } else if (effectiveHeading >= 0 && effectiveHeading <= 50) {
              effectiveHeading = 0;
            } else if (effectiveHeading >= 260 && effectiveHeading <= 310) {
              effectiveHeading = 90;
            } else if (effectiveHeading >= 170 && effectiveHeading <= 230) {
              effectiveHeading = 180;
            }
            const rad = effectiveHeading * Math.PI / 180;

            const stepPx = stepLengthMeters * pixelsPerMeter;
            userX += stepPx * Math.cos(rad);
            userY += stepPx * Math.sin(rad);

            addTrajectoryPoint(userX, userY);
            document.getElementById("posX").innerText = userX.toFixed(1);
            document.getElementById("posY").innerText = userY.toFixed(1);

            lastPeakTime = now;
          }
          peakDetected = false;
        }
      }

      // 4) Update UI for acceleration values
      document.getElementById("accX").innerText = linX.toFixed(2);
      document.getElementById("accY").innerText = linY.toFixed(2);
      document.getElementById("accZ").innerText = linZ.toFixed(2);

      document.getElementById("status").innerText = isStationary
        ? "Stationary (No real steps)."
        : "Moving...";

      // 5) Redraw the canvas
      drawEverything();
    });

    // E) Reset button to clear position and steps
    document.getElementById("resetBtn").addEventListener("click", () => {
      userX = null;
      userY = null;
      stepCount = 0;
      trajectoryPoints = [];
      peakDetected = false;
      lastPeakTime = 0;
      motionBuffer = [];
      isStationary = true;
      document.getElementById("stepsCount").innerText = "0";
      document.getElementById("posX").innerText = "0";
      document.getElementById("posY").innerText = "0";
      drawEverything();
    });

    // F) Calibrate heading button to set the current sensor heading as 0°
    document.getElementById("calibrateBtn").addEventListener("click", () => {
      baseHeading = heading;
      useCalibratedHeading = true;
      alert("Heading calibrated! Current orientation is now considered 0°.");
    });

    // Initial status
    document.getElementById("status").innerText = "Waiting for sensor data...";
  </script>
</body>
</html>
