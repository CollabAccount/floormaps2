<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Floor Plan Trajectory with Step Tracking</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    h1 {
      margin: 0.5em 0 0.2em;
    }
    #info {
      margin-bottom: 0.5em;
      font-size: 0.9em;
    }
    #floorCanvas {
      background: #fff;
      cursor: crosshair;
    }
    #stats {
      margin: 0.5em 0;
      font-size: 1em;
    }
    .bold {
      font-weight: bold;
    }
    button {
      margin: 0.5em;
      padding: 0.5em 1em;
      font-size: 1em;
      cursor: pointer;
    }
    #status {
      font-weight: bold;
      color: blue;
      margin-top: 0.5em;
    }
  </style>
</head>
<body>
  <h1>Floor Plan Live Tracking</h1>
  <div id="info">
    Click on the floor plan to set your <strong>starting position</strong>.<br/>
    Then move with your device in hand to see live tracking and heading.
  </div>

  <canvas id="floorCanvas" width="800" height="600"></canvas>
  
  <div id="stats">
    <p><strong>Steps:</strong> <span id="stepsCount">0</span></p>
    <p><strong>Heading:</strong> <span id="headingDeg">0</span>°</p>
    <p><strong>Position (Canvas px):</strong> 
      X=<span id="posX">0</span>, 
      Y=<span id="posY">0</span>
    </p>
    <p><strong>Acceleration (Filtered):</strong> 
      <span id="accX">0</span>, 
      <span id="accY">0</span>, 
      <span id="accZ">0</span>
    </p>
    <button id="resetBtn">Reset</button>
    <button id="calibrateBtn">Calibrate Heading</button>
    <div id="status">Initializing...</div>
  </div>

  <!-- Kalman filter library for smoothing orientation -->
  <script src="https://cdn.jsdelivr.net/npm/kalmanjs"></script>

  <script>
    /********************************************************************
     * 1) LOAD THE FLOOR PLAN IMAGE INTO THE CANVAS
     ********************************************************************/
    const canvas = document.getElementById("floorCanvas");
    const ctx = canvas.getContext("2d");

    // Replace this with your own floor plan image path if needed:
    const floorPlanSrc = "image.png"; 
    const floorPlan = new Image();
    floorPlan.src = floorPlanSrc;

    // We'll draw this image each time we update the canvas
    function drawFloorPlan() {
      ctx.drawImage(floorPlan, 0, 0, canvas.width, canvas.height);
    }

    /********************************************************************
     * 2) USER POSITION, STEP DETECTION, AND TRAJECTORY
     ********************************************************************/
    let userX = null;    // in canvas pixels
    let userY = null;    // in canvas pixels
    let heading = 0;     // device orientation in degrees
    let baseHeading = 0; // heading offset for calibration
    let useCalibratedHeading = false;

    // Trajectory storage
    let trajectoryPoints = []; // array of {x, y} in canvas coords

    // Step detection variables (peak–valley approach)
    let stepCount = 0;
    const stepLengthMeters = 0.7;     // average step length in meters
    const pixelsPerMeter = 2;        // scale factor (adjust to match image scale)
    const stepThresholdHigh = 1.5;    // threshold for "peak"
    const stepThresholdLow = 0.8;     // threshold for "valley"
    let peakDetected = false;
    let lastPeakTime = 0;
    let minStepInterval = 400;        // ms between steps

    // Gravity estimation for high-pass filtering
    let gravityX = 0, gravityY = 0, gravityZ = 0;
    const alpha = 0.9;

    // For simpler code, we skip advanced "stationary detection" here,
    // but you can adapt from earlier examples if desired.

    // Kalman filter for smoothing heading
    const headingKF = new KalmanFilter({ R: 0.01, Q: 3 });

    /********************************************************************
     * 3) DRAWING FUNCTIONS
     ********************************************************************/
    function drawEverything() {
      // 1) Clear and draw the floor plan
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFloorPlan();

      // 2) Draw the trajectory line
      if (trajectoryPoints.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        for (let i = 0; i < trajectoryPoints.length; i++) {
          let pt = trajectoryPoints[i];
          if (i === 0) {
            ctx.moveTo(pt.x, pt.y);
          } else {
            ctx.lineTo(pt.x, pt.y);
          }
        }
        ctx.stroke();
      }

      // 3) Draw the current position + direction arrow
      if (userX !== null && userY !== null) {
        // Draw a small dot
        ctx.beginPath();
        ctx.arc(userX, userY, 5, 0, 2 * Math.PI);
        ctx.fillStyle = "red";
        ctx.fill();

        // Draw heading arrow
        // Adjust heading if calibrated
        let usedHeading = useCalibratedHeading ? (heading - baseHeading) : heading;
        usedHeading = (usedHeading + 360) % 360; // normalize 0..360
        let rad = usedHeading * Math.PI / 180;

        // arrow length in pixels
        const arrowLen = 30;
        let arrowX = userX + arrowLen * Math.cos(rad);
        let arrowY = userY + arrowLen * Math.sin(rad);

        // Draw line for arrow
        ctx.beginPath();
        ctx.moveTo(userX, userY);
        ctx.lineTo(arrowX, arrowY);
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Optional: arrowhead
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(
          arrowX - 5 * Math.cos(rad - Math.PI / 6),
          arrowY - 5 * Math.sin(rad - Math.PI / 6)
        );
        ctx.lineTo(
          arrowX - 5 * Math.cos(rad + Math.PI / 6),
          arrowY - 5 * Math.sin(rad + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = "blue";
        ctx.fill();
      }
    }

    // Add a new point to the trajectory if it differs enough
    function addTrajectoryPoint(x, y) {
      // Only add if we have a previous point or it's the first time
      if (trajectoryPoints.length === 0) {
        trajectoryPoints.push({ x, y });
        return;
      }
      let last = trajectoryPoints[trajectoryPoints.length - 1];
      let dx = x - last.x;
      let dy = y - last.y;
      if (Math.sqrt(dx*dx + dy*dy) > 2) { 
        // only add if >2px from last point (to reduce clutter)
        trajectoryPoints.push({ x, y });
      }
    }

    /********************************************************************
     * 4) EVENT LISTENERS
     ********************************************************************/

    // A) LOAD IMAGE, then draw
    floorPlan.onload = function() {
      drawEverything();
    };

    // B) CLICK CANVAS TO SET STARTING POSITION
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      userX = e.clientX - rect.left;
      userY = e.clientY - rect.top;

      // Reset trajectory to start from here
      trajectoryPoints = [];
      addTrajectoryPoint(userX, userY);

      drawEverything();
    });

    // C) DEVICE ORIENTATION -> get heading
    window.addEventListener("deviceorientation", (event) => {
      // alpha: 0..360, but can vary by device
      let rawHeading = event.alpha || 0;
      heading = headingKF.filter(rawHeading);
      document.getElementById("headingDeg").innerText = heading.toFixed(2);
    });

    // D) DEVICE MOTION -> step detection
    window.addEventListener("devicemotion", (event) => {
      if (userX === null || userY === null) {
        // If user hasn't clicked to set starting position, do nothing
        return;
      }

      // 1) gravity removal
      let rawX = event.accelerationIncludingGravity.x || 0;
      let rawY = event.accelerationIncludingGravity.y || 0;
      let rawZ = event.accelerationIncludingGravity.z || 0;

      gravityX = alpha * gravityX + (1 - alpha) * rawX;
      gravityY = alpha * gravityY + (1 - alpha) * rawY;
      gravityZ = alpha * gravityZ + (1 - alpha) * rawZ;

      let linX = rawX - gravityX;
      let linY = rawY - gravityY;
      let linZ = rawZ - gravityZ;

      // 2) magnitude
      let magnitude = Math.sqrt(linX*linX + linY*linY + linZ*linZ);

      // 3) step detection (peak–valley)
      let now = performance.now();
      if (!peakDetected && magnitude > stepThresholdHigh) {
        peakDetected = true;
      } else if (peakDetected && magnitude < stepThresholdLow) {
        if (now - lastPeakTime > minStepInterval) {
          stepCount++;
          document.getElementById("stepsCount").innerText = stepCount;

          // Move user in canvas coords
          //  - Convert heading to radians
          let usedHeading = useCalibratedHeading ? (heading - baseHeading) : heading;
          usedHeading = (usedHeading + 360) % 360;
          let rad = usedHeading * Math.PI / 180;

          // stepLength in pixels
          let stepLengthPx = stepLengthMeters * pixelsPerMeter;
          userX += stepLengthPx * Math.cos(rad);
          userY += stepLengthPx * Math.sin(rad);

          // Save trajectory point
          addTrajectoryPoint(userX, userY);

          // Update stats
          document.getElementById("posX").innerText = userX.toFixed(1);
          document.getElementById("posY").innerText = userY.toFixed(1);

          lastPeakTime = now;
        }
        peakDetected = false;
      }

      // 4) Update displayed acceleration
      document.getElementById("accX").innerText = linX.toFixed(2);
      document.getElementById("accY").innerText = linY.toFixed(2);
      document.getElementById("accZ").innerText = linZ.toFixed(2);

      // 5) Redraw
      drawEverything();
    });

    // E) RESET BUTTON
    document.getElementById("resetBtn").addEventListener("click", () => {
      userX = null;
      userY = null;
      stepCount = 0;
      trajectoryPoints = [];
      peakDetected = false;
      lastPeakTime = 0;
      document.getElementById("stepsCount").innerText = "0";
      document.getElementById("posX").innerText = "0";
      document.getElementById("posY").innerText = "0";
      drawEverything();
    });

    // F) CALIBRATE HEADING
    document.getElementById("calibrateBtn").addEventListener("click", () => {
      baseHeading = heading;
      useCalibratedHeading = true;
      alert("Heading calibrated! Current device orientation is now treated as 0°.");
    });

    // Just set initial status
    document.getElementById("status").innerText = "Waiting for sensor data...";
  </script>
</body>
</html>
